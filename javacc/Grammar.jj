options {
    LOOKAHEAD = 1;
}

PARSER_BEGIN(Grammar)
public class Grammar
{
    public static void main(String[] args) throws ParseException {
      	System.out.println("Write an arithmetic expression:");
		Grammar grammar = new Grammar(System.in);
		SimpleNode root = grammar.Program(); // returns reference to root node

		root.dump(""); // prints the tree on the screen

		System.out.println("Expression value: "+ grammar.eval(root));
    }

}
PARSER_END(Grammar)

SKIP :
{
	" " | "\r" | "\t"
}

TOKEN:
{
    < INTEGER: (["0"-"9"])+ >|
    < LF: "\n" >
}

// Identifier and IntegerLiteral shall obey to the lexical rules of the Java programming language
// Placeholders
void Identifier():{}
{
    "identifier"
}

void IntegerLiteral():{}
{
    "identifierliteral"
}

// Program = ImportDeclaration, ClassDeclaration, EOF
SimpleNode Program(): {}
{
   ImportDeclaration() ClassDeclaration() <EOF>  {return jjtThis;} // Java code inside brackets
}

// ImportDeclaration = {"import", Identifier, { ”.”, Identifier }, ";"};
void ImportDeclaration(): {}
{
    ("import" Identifier() ("." Identifier())* ";")*
}

// ClassDeclaration = "class", Identifier, [ "extends", Identifier ], "{", { VarDeclaration }, { MethodDeclaration } "}";
void ClassDeclaration(): {}
{
    "class" Identifier() ("extends" Identifier())? "{" (VarDeclaration())* (MethodDeclaration())* "}"
}

// VarDeclaration = Type, Identifier, ";";
void VarDeclaration(): {}
{
    Type() Identifier() ";"
}

/*
MethodDeclaration = "public", Type, Identifier, "(", [ Type, Identifier, { ",", Type, Identifier }, ], ")", "{", { VarDeclaration }, { Statement }, "return", Expression, ";", "}"
|"public", "static", "void", "main", "(", "String", "[",
"]", Identifier, ")", "{", { VarDeclaration }, { Statement }, "}"
;
*/
void MethodDeclaration(): {}
{
    "public" Type() Identifier() "(" (Type() Identifier() ("," Type() Identifier())*)? ")"
    "{" (VarDeclaration())* (Statement())* "return" Expression() ";" "}"
    | "public" "static" "void" "main" "(" "String" "[" "]" Identifier() ")"
    "{" (VarDeclaration())* (Statement())* "return" Expression() ";" "}"
}

/*
Type = "int", "[", "]"
| "boolean"
|"int"
| Identifier
;
*/
void Type(): {}
{
    "int" "[" "]"
    | "boolean"
    | "int"
    | Identifier()
}

/*
Statement = "{", { Statement }, "}"
| "if", "(", Expression, ")", Statement, "else", Statement
| "while", "(", Expression, ")", Statement
| Expression, ";"
| Identifier, "=", Expression, ";"
| Identifier, "[", Expression, "]", "=", Expression, ";"
;
*/
void Statement(): {}
{
    "{" (Statement())* "}"
    | "if" "(" Expression() ")" Statement() "else" Statement()
    | "while" "(" Expression() ")" Statement()
    | Expression() ";"
    | Identifier() "=" Expression() ";"
    | Identifier() "[" Expression() "]" "=" Expression() ";"
}


/*
Expression = Expression, ( "&&" | "<" | "+" | "-" | "*" | "/") , Expression
| Expression, "[", Expression, "]"
| Expression, ".", "length"
| Expression, ".", Identifier, "(", [ Expression { ",", Expression } ], ")"
| IntegerLiteral
| "true"
| "false"
| Identifier
| "this"
| "new", "int", "[", Expression, "]"
| "new", Identifier ,"(" ,")"
| "!", Expression
| "(", Expression, ")"
;
*/
void Expression(): {}
{
    Expression() ("&&" | "<" | "+" | "-" | "*" | "/") Expression()
    | Expression() "[" Expression() "]"
    | Expression() "." "length"
    | Expression() "." Identifier() "(" (Expression() ("," Expression())*)? ")"
    | IntegerLiteral()
    | "true"
    | "false"
    | Identifier()
    | "this"
    | "new" "int" "[" Expression() "]"
    | "new" Identifier() "(" ")"
    | "!" Expression()
    | "(" Expression() ")"
}